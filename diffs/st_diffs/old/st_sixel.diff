diff --git a/FAQ b/FAQ
index 969b195..0f9609d 100644
--- a/FAQ
+++ b/FAQ
@@ -29,8 +29,8 @@ you can manually run `tic -sx st.info`.
 
 ## I would like to have utmp and/or scroll functionality by default
 
-You can add the absolute path of both programs in your config.h file. You only
-have to modify the value of utmp and scroll variables.
+You can add the absolute patch of both programs in your config.h
+file. You only have to modify the value of utmp and scroll variables.
 
 
 ## Why doesn't the Del key work in some programs?
diff --git a/LICENSE b/LICENSE
index 3cbf420..d80eb47 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,6 +1,6 @@
 MIT/X Consortium License
 
-© 2014-2022 Hiltjo Posthuma <hiltjo at codemadness dot org>
+© 2014-2020 Hiltjo Posthuma <hiltjo at codemadness dot org>
 © 2018 Devin J. Pohly <djpohly at gmail dot com>
 © 2014-2017 Quentin Rameau <quinq at fifth dot space>
 © 2009-2012 Aurélien APTEL <aurelien dot aptel at gmail dot com>
diff --git a/Makefile b/Makefile
index 470ac86..0bc8774 100644
--- a/Makefile
+++ b/Makefile
@@ -4,7 +4,7 @@
 
 include config.mk
 
-SRC = st.c x.c
+SRC = st.c x.c sixel.c sixel_hls.c
 OBJ = $(SRC:.c=.o)
 
 all: options st
diff --git a/config.def.h b/config.def.h
index 91ab8ca..6f05dce 100644
--- a/config.def.h
+++ b/config.def.h
@@ -120,8 +120,6 @@ static const char *colorname[] = {
 	/* more colors can be added after 255 to use with DefaultXX */
 	"#cccccc",
 	"#555555",
-	"gray90", /* default foreground colour */
-	"black", /* default background colour */
 };
 
 
@@ -129,9 +127,9 @@ static const char *colorname[] = {
  * Default colors (colorname index)
  * foreground, background, cursor, reverse cursor
  */
-unsigned int defaultfg = 258;
-unsigned int defaultbg = 259;
-unsigned int defaultcs = 256;
+unsigned int defaultfg = 7;
+unsigned int defaultbg = 0;
+static unsigned int defaultcs = 256;
 static unsigned int defaultrcs = 257;
 
 /*
diff --git a/config.mk b/config.mk
index ddf278a..c070a4a 100644
--- a/config.mk
+++ b/config.mk
@@ -1,5 +1,5 @@
 # st version
-VERSION = 0.8.5
+VERSION = 0.8.4
 
 # Customize below to fit your system
 
@@ -30,7 +30,6 @@ STLDFLAGS = $(LIBS) $(LDFLAGS)
 #LIBS = -L$(X11LIB) -lm -lX11 -lutil -lXft \
 #       `$(PKG_CONFIG) --libs fontconfig` \
 #       `$(PKG_CONFIG) --libs freetype2`
-#MANPREFIX = ${PREFIX}/man
 
 # compiler and linker
 # CC = c99
diff --git a/sixel.c b/sixel.c
new file mode 100644
index 0000000..97b9c4d
--- /dev/null
+++ b/sixel.c
@@ -0,0 +1,607 @@
+// sixel.c (part of mintty)
+// originally written by kmiya@cluti (https://github.com/saitoha/sixel/blob/master/fromsixel.c)
+// Licensed under the terms of the GNU General Public License v3 or later.
+
+#include <stdlib.h>
+#include <string.h>  /* memcpy */
+
+#include "sixel.h"
+#include "sixel_hls.h"
+
+#define SIXEL_RGB(r, g, b) ((r) + ((g) << 8) +  ((b) << 16))
+#define SIXEL_PALVAL(n,a,m) (((n) * (a) + ((m) / 2)) / (m))
+#define SIXEL_XRGB(r,g,b) SIXEL_RGB(SIXEL_PALVAL(r, 255, 100), SIXEL_PALVAL(g, 255, 100), SIXEL_PALVAL(b, 255, 100))
+
+static sixel_color_t const sixel_default_color_table[] = {
+	SIXEL_XRGB( 0,  0,  0),  /*  0 Black    */
+	SIXEL_XRGB(20, 20, 80),  /*  1 Blue     */
+	SIXEL_XRGB(80, 13, 13),  /*  2 Red      */
+	SIXEL_XRGB(20, 80, 20),  /*  3 Green    */
+	SIXEL_XRGB(80, 20, 80),  /*  4 Magenta  */
+	SIXEL_XRGB(20, 80, 80),  /*  5 Cyan     */
+	SIXEL_XRGB(80, 80, 20),  /*  6 Yellow   */
+	SIXEL_XRGB(53, 53, 53),  /*  7 Gray 50% */
+	SIXEL_XRGB(26, 26, 26),  /*  8 Gray 25% */
+	SIXEL_XRGB(33, 33, 60),  /*  9 Blue*    */
+	SIXEL_XRGB(60, 26, 26),  /* 10 Red*     */
+	SIXEL_XRGB(33, 60, 33),  /* 11 Green*   */
+	SIXEL_XRGB(60, 33, 60),  /* 12 Magenta* */
+	SIXEL_XRGB(33, 60, 60),  /* 13 Cyan*    */
+	SIXEL_XRGB(60, 60, 33),  /* 14 Yellow*  */
+	SIXEL_XRGB(80, 80, 80),  /* 15 Gray 75% */
+};
+
+static int
+set_default_color(sixel_image_t *image)
+{
+	int i;
+	int n;
+	int r;
+	int g;
+	int b;
+
+	/* palette initialization */
+	for (n = 1; n < 17; n++) {
+		image->palette[n] = sixel_default_color_table[n - 1];
+	}
+
+	/* colors 17-232 are a 6x6x6 color cube */
+	for (r = 0; r < 6; r++) {
+		for (g = 0; g < 6; g++) {
+			for (b = 0; b < 6; b++) {
+				image->palette[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);
+			}
+		}
+	}
+
+	/* colors 233-256 are a grayscale ramp, intentionally leaving out */
+	for (i = 0; i < 24; i++) {
+		image->palette[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);
+	}
+
+	for (; n < DECSIXEL_PALETTE_MAX; n++) {
+		image->palette[n] = SIXEL_RGB(255, 255, 255);
+	}
+
+	return (0);
+}
+
+static int
+sixel_image_init(
+    sixel_image_t    *image,
+    int              width,
+    int              height,
+    int              fgcolor,
+    int              bgcolor,
+    int              use_private_register)
+{
+	int status = (-1);
+	size_t size;
+
+	size = (size_t)(width * height) * sizeof(sixel_color_no_t);
+	image->width = width;
+	image->height = height;
+	image->data = (sixel_color_no_t *)malloc(size);
+	image->ncolors = 2;
+	image->use_private_register = use_private_register;
+
+	if (image->data == NULL) {
+		status = (-1);
+		goto end;
+	}
+	memset(image->data, 0, size);
+
+	image->palette[0] = bgcolor;
+
+	if (image->use_private_register)
+		image->palette[1] = fgcolor;
+
+	image->palette_modified = 0;
+
+	status = (0);
+
+end:
+	return status;
+}
+
+
+static int
+image_buffer_resize(
+    sixel_image_t   *image,
+    int              width,
+    int              height)
+{
+	int status = (-1);
+	size_t size;
+	sixel_color_no_t *alt_buffer;
+	int n;
+	int min_height;
+
+	size = (size_t)(width * height) * sizeof(sixel_color_no_t);
+	alt_buffer = (sixel_color_no_t *)malloc(size);
+	if (alt_buffer == NULL) {
+		/* free source image */
+		free(image->data);
+		image->data = NULL;
+		status = (-1);
+		goto end;
+	}
+
+	min_height = height > image->height ? image->height: height;
+	if (width > image->width) {  /* if width is extended */
+		for (n = 0; n < min_height; ++n) {
+			/* copy from source image */
+			memcpy(alt_buffer + width * n,
+			       image->data + image->width * n,
+			       (size_t)image->width * sizeof(sixel_color_no_t));
+			/* fill extended area with background color */
+			memset(alt_buffer + width * n + image->width,
+			       0,
+			       (size_t)(width - image->width) * sizeof(sixel_color_no_t));
+		}
+	} else {
+		for (n = 0; n < min_height; ++n) {
+			/* copy from source image */
+			memcpy(alt_buffer + width * n,
+			       image->data + image->width * n,
+			       (size_t)width * sizeof(sixel_color_no_t));
+		}
+	}
+
+	if (height > min_height) {  /* if height is extended */
+		/* fill extended area with background color */
+		memset(alt_buffer + width * image->height,
+		       0,
+		       (size_t)(width * (height - image->height)) * sizeof(sixel_color_no_t));
+	}
+
+	/* free source image */
+	free(image->data);
+
+	image->data = alt_buffer;
+	image->width = width;
+	image->height = height;
+
+	status = (0);
+
+end:
+	return status;
+}
+
+static void
+sixel_image_deinit(sixel_image_t *image)
+{
+	free(image->data);
+	image->data = NULL;
+}
+
+int
+sixel_parser_init(sixel_state_t *st,
+                  sixel_color_t fgcolor, sixel_color_t bgcolor,
+                  unsigned char use_private_register,
+                  int cell_width, int cell_height)
+{
+	int status = (-1);
+
+	st->state = PS_DECSIXEL;
+	st->pos_x = 0;
+	st->pos_y = 0;
+	st->max_x = 0;
+	st->max_y = 0;
+	st->attributed_pan = 2;
+	st->attributed_pad = 1;
+	st->attributed_ph = 0;
+	st->attributed_pv = 0;
+	st->repeat_count = 1;
+	st->color_index = 16;
+	st->grid_width = cell_width;
+	st->grid_height = cell_height;
+	st->nparams = 0;
+	st->param = 0;
+
+	/* buffer initialization */
+	status = sixel_image_init(&st->image, 1, 1, fgcolor, bgcolor, use_private_register);
+
+	return status;
+}
+
+int
+sixel_parser_set_default_color(sixel_state_t *st)
+{
+	return set_default_color(&st->image);
+}
+
+int
+sixel_parser_finalize(sixel_state_t *st, unsigned char *pixels)
+{
+	int status = (-1);
+	int sx;
+	int sy;
+	sixel_image_t *image = &st->image;
+	int x, y;
+	sixel_color_no_t *src;
+	unsigned char *dst;
+	int color;
+
+	if (++st->max_x < st->attributed_ph)
+		st->max_x = st->attributed_ph;
+
+	if (++st->max_y < st->attributed_pv)
+		st->max_y = st->attributed_pv;
+
+	sx = (st->max_x + st->grid_width - 1) / st->grid_width * st->grid_width;
+	sy = (st->max_y + st->grid_height - 1) / st->grid_height * st->grid_height;
+
+	if (image->width > sx || image->height > sy) {
+		status = image_buffer_resize(image, sx, sy);
+		if (status < 0)
+			goto end;
+	}
+
+	if (image->use_private_register && image->ncolors > 2 && !image->palette_modified) {
+		status = set_default_color(image);
+		if (status < 0)
+			goto end;
+	}
+
+	src = st->image.data;
+	dst = pixels;
+	for (y = 0; y < st->image.height; ++y) {
+		for (x = 0; x < st->image.width; ++x) {
+			color = st->image.palette[*src++];
+			*dst++ = color >> 16 & 0xff;   /* b */
+			*dst++ = color >> 8 & 0xff;    /* g */
+			*dst++ = color >> 0 & 0xff;    /* r */
+			dst++;                         /* a */
+		}
+	}
+	/* fill bottom padding with bgcolor */
+	for (; y < st->image.height; ++y) {
+		for (x = 0; x < st->image.width; ++x) {
+			color = st->image.palette[0];  /* bgcolor */
+			*dst++ = color >> 16 & 0xff;   /* b */
+			*dst++ = color >> 8 & 0xff;    /* g */
+			*dst++ = color >> 0 & 0xff;    /* r */
+			dst++;                         /* a */
+		}
+	}
+
+	status = (0);
+
+end:
+	return status;
+}
+
+/* convert sixel data into indexed pixel bytes and palette data */
+int
+sixel_parser_parse(sixel_state_t *st, unsigned char *p, size_t len)
+{
+	int status = (-1);
+	int n;
+	int i;
+	int x;
+	int y;
+	int bits;
+	int sixel_vertical_mask;
+	int sx;
+	int sy;
+	int c;
+	int pos;
+	int newwidth, newheight;
+	unsigned char *p0 = p;
+	sixel_image_t *image = &st->image;
+
+	if (! image->data)
+		goto end;
+
+	while (p < p0 + len) {
+		switch (st->state) {
+		case PS_ESC:
+			goto end;
+
+		case PS_DECSIXEL:
+			switch (*p) {
+			case '\x1b':
+				st->state = PS_ESC;
+				p++;
+				break;
+			case '"':
+				st->param = 0;
+				st->nparams = 0;
+				st->state = PS_DECGRA;
+				p++;
+				break;
+			case '!':
+				st->param = 0;
+				st->nparams = 0;
+				st->state = PS_DECGRI;
+				p++;
+				break;
+			case '#':
+				st->param = 0;
+				st->nparams = 0;
+				st->state = PS_DECGCI;
+				p++;
+				break;
+			case '$':
+				/* DECGCR Graphics Carriage Return */
+				st->pos_x = 0;
+				p++;
+				break;
+			case '-':
+				/* DECGNL Graphics Next Line */
+				st->pos_x = 0;
+				if (st->pos_y < DECSIXEL_HEIGHT_MAX - 5 - 6)
+					st->pos_y += 6;
+				else
+					st->pos_y = DECSIXEL_HEIGHT_MAX + 1;
+				p++;
+				break;
+			default:
+				if (*p >= '?' && *p <= '~') {  /* sixel characters */
+					newwidth = st->pos_x + st->repeat_count;
+					newheight = st->attributed_pv > 0 ? st->attributed_pv : st->pos_y + 6;
+					if ((image->width < newwidth || image->height < newheight) &&
+					    image->width < DECSIXEL_WIDTH_MAX && image->height < DECSIXEL_HEIGHT_MAX) {
+						sx = image->width < newwidth ? newwidth : image->width;
+						sy = newheight;
+
+						if (sx > DECSIXEL_WIDTH_MAX)
+							sx = DECSIXEL_WIDTH_MAX;
+						if (sy > DECSIXEL_HEIGHT_MAX)
+							sy = DECSIXEL_HEIGHT_MAX;
+
+						status = image_buffer_resize(image, sx, sy);
+						if (status < 0)
+							goto end;
+					}
+
+					if (st->color_index > image->ncolors)
+						image->ncolors = st->color_index;
+
+					if (st->pos_x + st->repeat_count > image->width)
+						st->repeat_count = image->width - st->pos_x;
+
+					if (st->repeat_count > 0 && st->pos_y - 5 < image->height) {
+						bits = *p - '?';
+						if (bits != 0) {
+							sixel_vertical_mask = 0x01;
+							if (st->repeat_count <= 1) {
+								for (i = 0; i < 6; i++) {
+									if ((bits & sixel_vertical_mask) != 0) {
+										pos = image->width * (st->pos_y + i) + st->pos_x;
+										image->data[pos] = st->color_index;
+										if (st->max_x < st->pos_x)
+											st->max_x = st->pos_x;
+										if (st->max_y < (st->pos_y + i))
+											st->max_y = st->pos_y + i;
+									}
+									sixel_vertical_mask <<= 1;
+								}
+							} else {
+								/* st->repeat_count > 1 */
+								for (i = 0; i < 6; i++) {
+									if ((bits & sixel_vertical_mask) != 0) {
+										c = sixel_vertical_mask << 1;
+										for (n = 1; (i + n) < 6; n++) {
+											if ((bits & c) == 0)
+												break;
+											c <<= 1;
+										}
+										for (y = st->pos_y + i; y < st->pos_y + i + n; ++y) {
+											for (x = st->pos_x; x < st->pos_x + st->repeat_count; ++x)
+												image->data[image->width * y + x] = st->color_index;
+										}
+										if (st->max_x < (st->pos_x + st->repeat_count - 1))
+											st->max_x = st->pos_x + st->repeat_count - 1;
+										if (st->max_y < (st->pos_y + i + n - 1))
+											st->max_y = st->pos_y + i + n - 1;
+										i += (n - 1);
+										sixel_vertical_mask <<= (n - 1);
+									}
+									sixel_vertical_mask <<= 1;
+								}
+							}
+						}
+					}
+					if (st->repeat_count > 0)
+						st->pos_x += st->repeat_count;
+					st->repeat_count = 1;
+				}
+				p++;
+				break;
+			}
+			break;
+
+		case PS_DECGRA:
+			/* DECGRA Set Raster Attributes " Pan; Pad; Ph; Pv */
+			switch (*p) {
+			case '\x1b':
+				st->state = PS_ESC;
+				p++;
+				break;
+			case '0':
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+			case '9':
+				st->param = st->param * 10 + *p - '0';
+				if (st->param > DECSIXEL_PARAMVALUE_MAX)
+					st->param = DECSIXEL_PARAMVALUE_MAX;
+				p++;
+				break;
+			case ';':
+				if (st->nparams < DECSIXEL_PARAMS_MAX)
+					st->params[st->nparams++] = st->param;
+				st->param = 0;
+				p++;
+				break;
+			default:
+				if (st->nparams < DECSIXEL_PARAMS_MAX)
+					st->params[st->nparams++] = st->param;
+				if (st->nparams > 0)
+					st->attributed_pad = st->params[0];
+				if (st->nparams > 1)
+					st->attributed_pan = st->params[1];
+				if (st->nparams > 2 && st->params[2] > 0)
+					st->attributed_ph = st->params[2];
+				if (st->nparams > 3 && st->params[3] > 0)
+					st->attributed_pv = st->params[3];
+
+				if (st->attributed_pan <= 0)
+					st->attributed_pan = 1;
+				if (st->attributed_pad <= 0)
+					st->attributed_pad = 1;
+
+				if (image->width < st->attributed_ph ||
+				        image->height < st->attributed_pv) {
+					sx = st->attributed_ph;
+					if (image->width > st->attributed_ph)
+						sx = image->width;
+
+					sy = st->attributed_pv;
+					if (image->height > st->attributed_pv)
+						sy = image->height;
+
+					sx = (sx + st->grid_width - 1) / st->grid_width * st->grid_width;
+					sy = (sy + st->grid_height - 1) / st->grid_height * st->grid_height;
+
+					if (sx > DECSIXEL_WIDTH_MAX)
+						sx = DECSIXEL_WIDTH_MAX;
+					if (sy > DECSIXEL_HEIGHT_MAX)
+						sy = DECSIXEL_HEIGHT_MAX;
+
+					status = image_buffer_resize(image, sx, sy);
+					if (status < 0)
+						goto end;
+				}
+				st->state = PS_DECSIXEL;
+				st->param = 0;
+				st->nparams = 0;
+			}
+			break;
+
+		case PS_DECGRI:
+			/* DECGRI Graphics Repeat Introducer ! Pn Ch */
+			switch (*p) {
+			case '\x1b':
+				st->state = PS_ESC;
+				p++;
+				break;
+			case '0':
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+			case '9':
+				st->param = st->param * 10 + *p - '0';
+				if (st->param > DECSIXEL_PARAMVALUE_MAX)
+					st->param = DECSIXEL_PARAMVALUE_MAX;
+				p++;
+				break;
+			default:
+				st->repeat_count = st->param;
+				if (st->repeat_count == 0)
+					st->repeat_count = 1;
+				st->state = PS_DECSIXEL;
+				st->param = 0;
+				st->nparams = 0;
+				break;
+			}
+			break;
+
+		case PS_DECGCI:
+			/* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */
+			switch (*p) {
+			case '\x1b':
+				st->state = PS_ESC;
+				p++;
+				break;
+			case '0':
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+			case '9':
+				st->param = st->param * 10 + *p - '0';
+				if (st->param > DECSIXEL_PARAMVALUE_MAX)
+					st->param = DECSIXEL_PARAMVALUE_MAX;
+				p++;
+				break;
+			case ';':
+				if (st->nparams < DECSIXEL_PARAMS_MAX)
+					st->params[st->nparams++] = st->param;
+				st->param = 0;
+				p++;
+				break;
+			default:
+				st->state = PS_DECSIXEL;
+				if (st->nparams < DECSIXEL_PARAMS_MAX)
+					st->params[st->nparams++] = st->param;
+				st->param = 0;
+
+				if (st->nparams > 0) {
+					st->color_index = 1 + st->params[0];  /* offset 1(background color) added */
+					if (st->color_index < 0)
+						st->color_index = 0;
+					else if (st->color_index >= DECSIXEL_PALETTE_MAX)
+						st->color_index = DECSIXEL_PALETTE_MAX - 1;
+				}
+
+				if (st->nparams > 4) {
+					st->image.palette_modified = 1;
+					if (st->params[1] == 1) {
+						/* HLS */
+						if (st->params[2] > 360)
+							st->params[2] = 360;
+						if (st->params[3] > 100)
+							st->params[3] = 100;
+						if (st->params[4] > 100)
+							st->params[4] = 100;
+						image->palette[st->color_index]
+						    = hls_to_rgb(st->params[2], st->params[3], st->params[4]);
+					} else if (st->params[1] == 2) {
+						/* RGB */
+						if (st->params[2] > 100)
+							st->params[2] = 100;
+						if (st->params[3] > 100)
+							st->params[3] = 100;
+						if (st->params[4] > 100)
+							st->params[4] = 100;
+						image->palette[st->color_index]
+						    = SIXEL_XRGB(st->params[2], st->params[3], st->params[4]);
+					}
+				}
+				break;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	status = (0);
+
+end:
+	return status;
+}
+
+void
+sixel_parser_deinit(sixel_state_t *st)
+{
+	if (st)
+		sixel_image_deinit(&st->image);
+}
diff --git a/sixel.h b/sixel.h
new file mode 100644
index 0000000..27448cf
--- /dev/null
+++ b/sixel.h
@@ -0,0 +1,61 @@
+#ifndef SIXEL_H
+#define SIXEL_H
+
+#include <unistd.h>
+#include <stdint.h>
+
+#define DECSIXEL_PARAMS_MAX 16
+#define DECSIXEL_PALETTE_MAX 1024
+#define DECSIXEL_PARAMVALUE_MAX 65535
+#define DECSIXEL_WIDTH_MAX 4096
+#define DECSIXEL_HEIGHT_MAX 4096
+
+typedef uint16_t sixel_color_no_t;
+typedef uint32_t sixel_color_t;
+
+typedef struct sixel_image_buffer {
+	sixel_color_no_t *data;
+	int width;
+	int height;
+	sixel_color_t palette[DECSIXEL_PALETTE_MAX];
+	sixel_color_no_t ncolors;
+	int palette_modified;
+	int use_private_register;
+} sixel_image_t;
+
+typedef enum parse_state {
+	PS_ESC        = 1,  /* ESC */
+	PS_DECSIXEL   = 2,  /* DECSIXEL body part ", $, -, ? ... ~ */
+	PS_DECGRA     = 3,  /* DECGRA Set Raster Attributes " Pan; Pad; Ph; Pv */
+	PS_DECGRI     = 4,  /* DECGRI Graphics Repeat Introducer ! Pn Ch */
+	PS_DECGCI     = 5,  /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */
+} parse_state_t;
+
+typedef struct parser_context {
+	parse_state_t state;
+	int pos_x;
+	int pos_y;
+	int max_x;
+	int max_y;
+	int attributed_pan;
+	int attributed_pad;
+	int attributed_ph;
+	int attributed_pv;
+	int repeat_count;
+	int color_index;
+	int bgindex;
+	int grid_width;
+	int grid_height;
+	int param;
+	int nparams;
+	int params[DECSIXEL_PARAMS_MAX];
+	sixel_image_t image;
+} sixel_state_t;
+
+int sixel_parser_init(sixel_state_t *st, sixel_color_t fgcolor, sixel_color_t bgcolor, unsigned char use_private_register, int cell_width, int cell_height);
+int sixel_parser_parse(sixel_state_t *st, unsigned char *p, size_t len);
+int sixel_parser_set_default_color(sixel_state_t *st);
+int sixel_parser_finalize(sixel_state_t *st, unsigned char *pixels);
+void sixel_parser_deinit(sixel_state_t *st);
+
+#endif
diff --git a/sixel_hls.c b/sixel_hls.c
new file mode 100644
index 0000000..4f157b2
--- /dev/null
+++ b/sixel_hls.c
@@ -0,0 +1,115 @@
+// sixel.c (part of mintty)
+// this function is derived from a part of graphics.c
+// in Xterm pl#310 originally written by Ross Combs.
+//
+// Copyright 2013,2014 by Ross Combs
+//
+//                         All Rights Reserved
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to
+// permit persons to whom the Software is furnished to do so, subject to
+// the following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+// IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
+// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+//
+// Except as contained in this notice, the name(s) of the above copyright
+// holders shall not be used in advertising or otherwise to promote the
+// sale, use or other dealings in this Software without prior written
+// authorization.
+
+#define SIXEL_RGB(r, g, b) (((r) << 16) + ((g) << 8) +  (b))
+
+int
+hls_to_rgb(int hue, int lum, int sat)
+{
+  double hs = (hue + 240) % 360;
+  double hv = hs / 360.0;
+  double lv = lum / 100.0;
+  double sv = sat / 100.0;
+  double c, x, m, c2;
+  double r1, g1, b1;
+  int r, g, b;
+  int hpi;
+
+  if (sat == 0) {
+    r = g = b = lum * 255 / 100;
+    return SIXEL_RGB(r, g, b);
+  }
+
+  if ((c2 = ((2.0 * lv) - 1.0)) < 0.0) {
+    c2 = -c2;
+  }
+  c = (1.0 - c2) * sv;
+  hpi = (int) (hv * 6.0);
+  x = (hpi & 1) ? c : 0.0;
+  m = lv - 0.5 * c;
+
+  switch (hpi) {
+  case 0:
+    r1 = c;
+    g1 = x;
+    b1 = 0.0;
+    break;
+  case 1:
+    r1 = x;
+    g1 = c;
+    b1 = 0.0;
+    break;
+  case 2:
+    r1 = 0.0;
+    g1 = c;
+    b1 = x;
+    break;
+  case 3:
+    r1 = 0.0;
+    g1 = x;
+    b1 = c;
+    break;
+  case 4:
+    r1 = x;
+    g1 = 0.0;
+    b1 = c;
+    break;
+  case 5:
+    r1 = c;
+    g1 = 0.0;
+    b1 = x;
+    break;
+  default:
+    return SIXEL_RGB(255, 255, 255);
+  }
+
+  r = (int) ((r1 + m) * 100.0 + 0.5);
+  g = (int) ((g1 + m) * 100.0 + 0.5);
+  b = (int) ((b1 + m) * 100.0 + 0.5);
+
+  if (r < 0) {
+    r = 0;
+  } else if (r > 100) {
+    r = 100;
+  }
+  if (g < 0) {
+    g = 0;
+  } else if (g > 100) {
+    g = 100;
+  }
+  if (b < 0) {
+    b = 0;
+  } else if (b > 100) {
+    b = 100;
+  }
+  return SIXEL_RGB(r * 255 / 100, g * 255 / 100, b * 255 / 100);
+}
diff --git a/sixel_hls.h b/sixel_hls.h
new file mode 100644
index 0000000..6176589
--- /dev/null
+++ b/sixel_hls.h
@@ -0,0 +1,7 @@
+/*
+ * Primary color hues:
+ *  blue:  0 degrees
+ *  red:   120 degrees
+ *  green: 240 degrees
+ */
+int hls_to_rgb(int hue, int lum, int sat);
diff --git a/st.c b/st.c
index 6ba467d..0037c19 100644
--- a/st.c
+++ b/st.c
@@ -17,6 +17,7 @@
 #include <unistd.h>
 #include <wchar.h>
 
+#include "sixel.h"
 #include "st.h"
 #include "win.h"
 
@@ -51,6 +52,7 @@ enum term_mode {
 	MODE_ECHO        = 1 << 4,
 	MODE_PRINT       = 1 << 5,
 	MODE_UTF8        = 1 << 6,
+	MODE_SIXEL       = 1 << 7,
 };
 
 enum cursor_movement {
@@ -77,11 +79,12 @@ enum charset {
 enum escape_state {
 	ESC_START      = 1,
 	ESC_CSI        = 2,
-	ESC_STR        = 4,  /* DCS, OSC, PM, APC */
+	ESC_STR        = 4,  /* OSC, PM, APC */
 	ESC_ALTCHARSET = 8,
 	ESC_STR_END    = 16, /* a final string was encountered */
 	ESC_TEST       = 32, /* Enter in test mode */
 	ESC_UTF8       = 64,
+	ESC_DCS        =128,
 };
 
 typedef struct {
@@ -128,6 +131,7 @@ typedef struct {
 	int icharset; /* selected charset for sequence */
 	int *tabs;
 	Rune lastc;   /* last printed char outside of sequence, 0 if control */
+	SixelContext sixel;
 } Term;
 
 /* CSI Escape sequence structs */
@@ -161,7 +165,7 @@ static void csidump(void);
 static void csihandle(void);
 static void csiparse(void);
 static void csireset(void);
-static void osc_color_response(int, int, int);
+static void dcshandle(void);
 static int eschandle(uchar);
 static void strdump(void);
 static void strhandle(void);
@@ -187,18 +191,18 @@ static void tputc(Rune);
 static void treset(void);
 static void tscrollup(int, int);
 static void tscrolldown(int, int);
-static void tsetattr(const int *, int);
-static void tsetchar(Rune, const Glyph *, int, int);
+static void tsetattr(int *, int);
+static void tsetchar(Rune, Glyph *, int, int);
 static void tsetdirt(int, int);
 static void tsetscroll(int, int);
 static void tswapscreen(void);
-static void tsetmode(int, int, const int *, int);
+static void tsetmode(int, int, int *, int);
 static int twrite(const char *, int, int);
 static void tfulldirt(void);
 static void tcontrolcode(uchar );
 static void tdectest(char );
 static void tdefutf8(char);
-static int32_t tdefcolor(const int *, int *, int);
+static int32_t tdefcolor(int *, int *, int);
 static void tdeftran(char);
 static void tstrsequence(uchar);
 
@@ -227,10 +231,10 @@ static int iofd = 1;
 static int cmdfd;
 static pid_t pid;
 
-static const uchar utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};
-static const uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
-static const Rune utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
-static const Rune utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
+static uchar utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};
+static uchar utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
+static Rune utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
+static Rune utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
 
 ssize_t
 xwrite(int fd, const char *s, size_t len)
@@ -270,14 +274,12 @@ xrealloc(void *p, size_t len)
 }
 
 char *
-xstrdup(const char *s)
+xstrdup(char *s)
 {
-	char *p;
-
-	if ((p = strdup(s)) == NULL)
+	if ((s = strdup(s)) == NULL)
 		die("strdup: %s\n", strerror(errno));
 
-	return p;
+	return s;
 }
 
 size_t
@@ -350,10 +352,25 @@ utf8validate(Rune *u, size_t i)
 	return i;
 }
 
+static const char base64_digits[] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 0,
+	63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, -1, 0, 0, 0, 0, 1,
+	2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+	22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34,
+	35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
 char
 base64dec_getc(const char **src)
 {
-	while (**src && !isprint((unsigned char)**src))
+	while (**src && !isprint(**src))
 		(*src)++;
 	return **src ? *((*src)++) : '=';  /* emulate padding if string ends */
 }
@@ -363,13 +380,6 @@ base64dec(const char *src)
 {
 	size_t in_len = strlen(src);
 	char *result, *dst;
-	static const char base64_digits[256] = {
-		[43] = 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
-		0, 0, 0, -1, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
-		13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0,
-		0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
-		40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
-	};
 
 	if (in_len % 4)
 		in_len += 4 - (in_len % 4);
@@ -513,7 +523,7 @@ selsnap(int *x, int *y, int direction)
 {
 	int newx, newy, xt, yt;
 	int delim, prevdelim;
-	const Glyph *gp, *prevgp;
+	Glyph *gp, *prevgp;
 
 	switch (sel.snap) {
 	case SNAP_WORD:
@@ -586,7 +596,7 @@ getsel(void)
 {
 	char *str, *ptr;
 	int y, bufsize, lastx, linelen;
-	const Glyph *gp, *last;
+	Glyph *gp, *last;
 
 	if (sel.ob.x == -1)
 		return NULL;
@@ -753,7 +763,7 @@ stty(char **args)
 }
 
 int
-ttynew(const char *line, char *cmd, const char *out, char **args)
+ttynew(char *line, char *cmd, char *out, char **args)
 {
 	int m, s;
 
@@ -786,15 +796,14 @@ ttynew(const char *line, char *cmd, const char *out, char **args)
 		break;
 	case 0:
 		close(iofd);
-		close(m);
 		setsid(); /* create a new process group */
 		dup2(s, 0);
 		dup2(s, 1);
 		dup2(s, 2);
 		if (ioctl(s, TIOCSCTTY, NULL) < 0)
 			die("ioctl TIOCSCTTY failed: %s\n", strerror(errno));
-		if (s > 2)
-			close(s);
+		close(s);
+		close(m);
 #ifdef __OpenBSD__
 		if (pledge("stdio getpw proc exec", NULL) == -1)
 			die("pledge\n");
@@ -1011,6 +1020,7 @@ void
 treset(void)
 {
 	uint i;
+	ImageList *im;
 
 	term.c = (TCursor){{
 		.mode = ATTR_NULL,
@@ -1033,6 +1043,9 @@ treset(void)
 		tclearregion(0, 0, term.col-1, term.row-1);
 		tswapscreen();
 	}
+
+	for (im = term.sixel.images; im; im = im->next)
+		im->should_delete = 1;
 }
 
 void
@@ -1047,9 +1060,12 @@ void
 tswapscreen(void)
 {
 	Line *tmp = term.line;
+	ImageList *im = term.sixel.images;
 
 	term.line = term.alt;
 	term.alt = tmp;
+	term.sixel.images = term.sixel.images_alt;
+	term.sixel.images_alt = im;
 	term.mode ^= MODE_ALTSCREEN;
 	tfulldirt();
 }
@@ -1070,6 +1086,8 @@ tscrolldown(int orig, int n)
 		term.line[i] = term.line[i-n];
 		term.line[i-n] = temp;
 	}
+	/* process scrolldown */
+	xsixelscrolldown(&term.sixel, n, term.bot);
 
 	selscroll(orig, n);
 }
@@ -1079,6 +1097,7 @@ tscrollup(int orig, int n)
 {
 	int i;
 	Line temp;
+	ImageList *im;
 
 	LIMIT(n, 0, term.bot-orig+1);
 
@@ -1091,6 +1110,9 @@ tscrollup(int orig, int n)
 		term.line[i+n] = temp;
 	}
 
+	/* process scrollup */
+	xsixelscrollup(&term.sixel, n, term.top);
+
 	selscroll(orig, -n);
 }
 
@@ -1182,9 +1204,9 @@ tmoveto(int x, int y)
 }
 
 void
-tsetchar(Rune u, const Glyph *attr, int x, int y)
+tsetchar(Rune u, Glyph *attr, int x, int y)
 {
-	static const char *vt100_0[62] = { /* 0x41 - 0x7e */
+	static char *vt100_0[62] = { /* 0x41 - 0x7e */
 		"↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
 		0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
 		0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
@@ -1296,7 +1318,7 @@ tdeleteline(int n)
 }
 
 int32_t
-tdefcolor(const int *attr, int *npar, int l)
+tdefcolor(int *attr, int *npar, int l)
 {
 	int32_t idx = -1;
 	uint r, g, b;
@@ -1346,7 +1368,7 @@ tdefcolor(const int *attr, int *npar, int l)
 }
 
 void
-tsetattr(const int *attr, int l)
+tsetattr(int *attr, int l)
 {
 	int i;
 	int32_t idx;
@@ -1464,9 +1486,9 @@ tsetscroll(int t, int b)
 }
 
 void
-tsetmode(int priv, int set, const int *args, int narg)
+tsetmode(int priv, int set, int *args, int narg)
 {
-	int alt; const int *lim;
+	int alt, *lim;
 
 	for (lim = args + narg; args < lim; ++args) {
 		if (priv) {
@@ -1593,6 +1615,23 @@ tsetmode(int priv, int set, const int *args, int narg)
 	}
 }
 
+void
+dcshandle(void)
+{
+	switch (csiescseq.mode[0]) {
+	default:
+		fprintf(stderr, "erresc: unknown csi ");
+		csidump();
+		/* die(""); */
+		break;
+	case 'q': /* DECSIXEL */
+		if (xsixelinit(&term.sixel) != 0)
+			perror("sixel_parser_init() failed");
+		term.mode |= MODE_SIXEL;
+		break;
+	}
+}
+
 void
 csihandle(void)
 {
@@ -1835,41 +1874,13 @@ csireset(void)
 	memset(&csiescseq, 0, sizeof(csiescseq));
 }
 
-void
-osc_color_response(int num, int index, int is_osc4)
-{
-	int n;
-	char buf[32];
-	unsigned char r, g, b;
-
-	if (xgetcolor(is_osc4 ? num : index, &r, &g, &b)) {
-		fprintf(stderr, "erresc: failed to fetch %s color %d\n",
-		        is_osc4 ? "osc4" : "osc",
-		        is_osc4 ? num : index);
-		return;
-	}
-
-	n = snprintf(buf, sizeof buf, "\033]%s%d;rgb:%02x%02x/%02x%02x/%02x%02x\007",
-	             is_osc4 ? "4;" : "", num, r, r, g, g, b, b);
-	if (n < 0 || n >= sizeof(buf)) {
-		fprintf(stderr, "error: %s while printing %s response\n",
-		        n < 0 ? "snprintf failed" : "truncation occurred",
-		        is_osc4 ? "osc4" : "osc");
-	} else {
-		ttywrite(buf, n, 1);
-	}
-}
-
 void
 strhandle(void)
 {
+	TermWindow win;
 	char *p = NULL, *dec;
 	int j, narg, par;
-	const struct { int idx; char *str; } osc_table[] = {
-		{ defaultfg, "foreground" },
-		{ defaultbg, "background" },
-		{ defaultcs, "cursor" }
-	};
+	int i;
 
 	term.esc &= ~(ESC_STR_END|ESC_STR);
 	strparse();
@@ -1903,35 +1914,14 @@ strhandle(void)
 				}
 			}
 			return;
-		case 10:
-		case 11:
-		case 12:
-			if (narg < 2)
-				break;
-			p = strescseq.args[1];
-			if ((j = par - 10) < 0 || j >= LEN(osc_table))
-				break; /* shouldn't be possible */
-
-			if (!strcmp(p, "?")) {
-				osc_color_response(par, osc_table[j].idx, 0);
-			} else if (xsetcolorname(osc_table[j].idx, p)) {
-				fprintf(stderr, "erresc: invalid %s color: %s\n",
-				        osc_table[j].str, p);
-			} else {
-				tfulldirt();
-			}
-			return;
 		case 4: /* color set */
 			if (narg < 3)
 				break;
 			p = strescseq.args[2];
 			/* FALLTHROUGH */
-		case 104: /* color reset */
+		case 104: /* color reset, here p = NULL */
 			j = (narg > 1) ? atoi(strescseq.args[1]) : -1;
-
-			if (p && !strcmp(p, "?")) {
-				osc_color_response(j, 0, 1);
-			} else if (xsetcolorname(j, p)) {
+			if (xsetcolorname(j, p)) {
 				if (par == 104 && narg <= 1)
 					return; /* color reset without parameter */
 				fprintf(stderr, "erresc: invalid color j=%d, p=%s\n",
@@ -1941,7 +1931,7 @@ strhandle(void)
 				 * TODO if defaultbg color is changed, borders
 				 * are dirty
 				 */
-				tfulldirt();
+				redraw();
 			}
 			return;
 		}
@@ -1950,6 +1940,19 @@ strhandle(void)
 		xsettitle(strescseq.args[0]);
 		return;
 	case 'P': /* DCS -- Device Control String */
+		if (IS_SET(MODE_SIXEL)) {
+			term.mode &= ~MODE_SIXEL;
+			xsixelnewimage(&term.sixel, term.c.x, term.c.y);
+			win = gettermwindow();
+			for (i = 0; i < (term.sixel.state.image.height + win.ch-1)/win.ch; ++i) {
+				int x;
+				tclearregion(term.c.x, term.c.y, term.c.x+(term.sixel.state.image.width+win.cw-1)/win.cw, term.c.y);
+				for (x = term.c.x; x < MIN(term.col, term.c.x+(term.sixel.state.image.width+win.cw-1)/win.cw); x++)
+					term.line[term.c.y][x].mode |= ATTR_SIXEL;
+				tnewline(1);
+			}
+		}
+		return;
 	case '_': /* APC -- Application Program Command */
 	case '^': /* PM -- Privacy Message */
 		return;
@@ -2067,7 +2070,7 @@ void
 tdumpline(int n)
 {
 	char buf[UTF_SIZ];
-	const Glyph *bp, *end;
+	Glyph *bp, *end;
 
 	bp = &term.line[n][0];
 	end = &bp[MIN(tlinelen(n), term.col) - 1];
@@ -2277,6 +2280,7 @@ eschandle(uchar ascii)
 		term.esc |= ESC_UTF8;
 		return 0;
 	case 'P': /* DCS -- Device Control String */
+		term.esc |= ESC_DCS;
 	case '_': /* APC -- Application Program Command */
 	case '^': /* PM -- Privacy Message */
 	case ']': /* OSC -- Operating System Command */
@@ -2374,13 +2378,20 @@ tputc(Rune u)
 	 * character.
 	 */
 	if (term.esc & ESC_STR) {
-		if (u == '\a' || u == 030 || u == 032 || u == 033 ||
-		   ISCONTROLC1(u)) {
-			term.esc &= ~(ESC_START|ESC_STR);
+		if (u == '\a' || u == 030 || u == 032 || u == 033 || ISCONTROLC1(u)) {
+			term.esc &= ~(ESC_START|ESC_STR|ESC_DCS);
 			term.esc |= ESC_STR_END;
 			goto check_control_code;
 		}
 
+		if (IS_SET(MODE_SIXEL)) {
+			if (xsixelparse(&term.sixel, (unsigned char *)&u, 1) != 0)
+				perror("sixel_parser_parse() failed");
+			return;
+		}
+		if (term.esc & ESC_DCS)
+			goto check_control_code;
+
 		if (strescseq.len+len >= strescseq.siz) {
 			/*
 			 * Here is a bug in terminals. If the user never sends
@@ -2431,6 +2442,15 @@ check_control_code:
 				csihandle();
 			}
 			return;
+		} else if (term.esc & ESC_DCS) {
+			csiescseq.buf[csiescseq.len++] = u;
+			if (BETWEEN(u, 0x40, 0x7E)
+					|| csiescseq.len >= \
+					sizeof(csiescseq.buf)-1) {
+				csiparse();
+				dcshandle();
+			}
+			return;
 		} else if (term.esc & ESC_UTF8) {
 			tdefutf8(u);
 		} else if (term.esc & ESC_ALTCHARSET) {
@@ -2473,10 +2493,6 @@ check_control_code:
 	if (width == 2) {
 		gp->mode |= ATTR_WIDE;
 		if (term.c.x+1 < term.col) {
-			if (gp[1].mode == ATTR_WIDE && term.c.x+2 < term.col) {
-				gp[2].u = ' ';
-				gp[2].mode &= ~ATTR_WDUMMY;
-			}
 			gp[1].u = '\0';
 			gp[1].mode = ATTR_WDUMMY;
 		}
@@ -2639,6 +2655,7 @@ draw(void)
 		cx--;
 
 	drawregion(0, 0, term.col, term.row);
+    xdrawsixel(&term.sixel, term.line, term.row, term.col);
 	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
 			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
 	term.ocx = cx;
diff --git a/st.h b/st.h
index fd3b0d8..ed4db48 100644
--- a/st.h
+++ b/st.h
@@ -33,6 +33,7 @@ enum glyph_attribute {
 	ATTR_WRAP       = 1 << 8,
 	ATTR_WIDE       = 1 << 9,
 	ATTR_WDUMMY     = 1 << 10,
+	ATTR_SIXEL      = 1 << 11,
 	ATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,
 };
 
@@ -69,6 +70,23 @@ typedef struct {
 
 typedef Glyph *Line;
 
+typedef struct _ImageList {
+	struct _ImageList *next, *prev;
+	unsigned char *pixels;
+	void *pixmap;
+	int width;
+	int height;
+	int x;
+	int y;
+	int should_delete;
+} ImageList;
+
+typedef struct _SixelContext {
+	sixel_state_t state;
+	ImageList *images;     /* sixel images */
+	ImageList *images_alt; /* sixel images for alternate screen */
+} SixelContext;
+
 typedef union {
 	int i;
 	uint ui;
@@ -91,7 +109,7 @@ void tnew(int, int);
 void tresize(int, int);
 void tsetdirtattr(int);
 void ttyhangup(void);
-int ttynew(const char *, char *, const char *, char **);
+int ttynew(char *, char *, char *, char **);
 size_t ttyread(void);
 void ttyresize(int, int);
 void ttywrite(const char *, size_t, int);
@@ -109,7 +127,7 @@ size_t utf8encode(Rune, char *);
 
 void *xmalloc(size_t);
 void *xrealloc(void *, size_t);
-char *xstrdup(const char *);
+char *xstrdup(char *);
 
 /* config.h globals */
 extern char *utmp;
@@ -123,4 +141,3 @@ extern char *termname;
 extern unsigned int tabspaces;
 extern unsigned int defaultfg;
 extern unsigned int defaultbg;
-extern unsigned int defaultcs;
diff --git a/win.h b/win.h
index 6de960d..eb436bb 100644
--- a/win.h
+++ b/win.h
@@ -23,19 +23,47 @@ enum win_mode {
 	                  |MODE_MOUSEMANY,
 };
 
+/* Purely graphic info */
+typedef struct {
+	int tw, th; /* tty width and height */
+	int w, h; /* window width and height */
+	int ch; /* char height */
+	int cw; /* char width  */
+	int mode; /* window state/mode flags */
+	int cursor; /* cursor style */
+} TermWindow;
+
+// /* Purely graphic info */
+// typedef struct {
+// 	int tw, th; /* tty width and height */
+// 	int w, h; /* window width and height */
+// 	int ch; /* char height */
+// 	int cw; /* char width  */
+// 	int cyo; /* char y offset */
+// 	int mode; /* window state/mode flags */
+// 	int cursor; /* cursor style */
+// } TermWindow;
+
+TermWindow gettermwindow(void);
 void xbell(void);
 void xclipcopy(void);
 void xdrawcursor(int, int, Glyph, int, int, Glyph);
 void xdrawline(Line, int, int, int);
+void xdrawsixel(SixelContext *, Line *, int, int);
 void xfinishdraw(void);
 void xloadcols(void);
 int xsetcolorname(int, const char *);
-int xgetcolor(int, unsigned char *, unsigned char *, unsigned char *);
 void xseticontitle(char *);
 void xsettitle(char *);
 int xsetcursor(int);
 void xsetmode(int, unsigned int);
 void xsetpointermotion(int);
 void xsetsel(char *);
+int xsixelinit(SixelContext *);
+void xsixelscrolldown(SixelContext *, int, int);
+void xsixelscrollup(SixelContext *, int, int);
+void xsixelnewimage(SixelContext *, int, int);
+int xsixelparse(SixelContext *, unsigned char *, int);
+void xsixeldeleteimage(SixelContext *, ImageList *);
 int xstartdraw(void);
 void xximspot(int, int);
diff --git a/x.c b/x.c
index 2a3bd38..568ad70 100644
--- a/x.c
+++ b/x.c
@@ -17,6 +17,7 @@
 
 char *argv0;
 #include "arg.h"
+#include "sixel.h"
 #include "st.h"
 #include "win.h"
 
@@ -48,7 +49,7 @@ typedef struct {
 /* X modifiers */
 #define XK_ANY_MOD    UINT_MAX
 #define XK_NO_MOD     0
-#define XK_SWITCH_MOD (1<<13|1<<14)
+#define XK_SWITCH_MOD (1<<13)
 
 /* function definitions used in config.h */
 static void clipcopy(const Arg *);
@@ -77,16 +78,6 @@ typedef XftDraw *Draw;
 typedef XftColor Color;
 typedef XftGlyphFontSpec GlyphFontSpec;
 
-/* Purely graphic info */
-typedef struct {
-	int tw, th; /* tty width and height */
-	int w, h; /* window width and height */
-	int ch; /* char height */
-	int cw; /* char width  */
-	int mode; /* window state/mode flags */
-	int cursor; /* cursor style */
-} TermWindow;
-
 typedef struct {
 	Display *dpy;
 	Colormap cmap;
@@ -156,7 +147,7 @@ static void xresize(int, int);
 static void xhints(void);
 static int xloadcolor(int, const char *, Color *);
 static int xloadfont(Font *, FcPattern *);
-static void xloadfonts(const char *, double);
+static void xloadfonts(char *, double);
 static void xunloadfont(Font *);
 static void xunloadfonts(void);
 static void xsetenv(void);
@@ -252,7 +243,13 @@ static char *opt_line  = NULL;
 static char *opt_name  = NULL;
 static char *opt_title = NULL;
 
-static uint buttons; /* bit field of pressed buttons */
+static int oldbutton = 3; /* button event on startup: 3 = release */
+
+TermWindow
+gettermwindow()
+{
+	return win;
+}
 
 void
 clipcopy(const Arg *dummy)
@@ -364,68 +361,61 @@ mousesel(XEvent *e, int done)
 void
 mousereport(XEvent *e)
 {
-	int len, btn, code;
-	int x = evcol(e), y = evrow(e);
-	int state = e->xbutton.state;
+	int len, x = evcol(e), y = evrow(e),
+	    button = e->xbutton.button, state = e->xbutton.state;
 	char buf[40];
 	static int ox, oy;
 
-	if (e->type == MotionNotify) {
+	/* from urxvt */
+	if (e->xbutton.type == MotionNotify) {
 		if (x == ox && y == oy)
 			return;
 		if (!IS_SET(MODE_MOUSEMOTION) && !IS_SET(MODE_MOUSEMANY))
 			return;
-		/* MODE_MOUSEMOTION: no reporting if no button is pressed */
-		if (IS_SET(MODE_MOUSEMOTION) && buttons == 0)
+		/* MOUSE_MOTION: no reporting if no button is pressed */
+		if (IS_SET(MODE_MOUSEMOTION) && oldbutton == 3)
 			return;
-		/* Set btn to lowest-numbered pressed button, or 12 if no
-		 * buttons are pressed. */
-		for (btn = 1; btn <= 11 && !(buttons & (1<<(btn-1))); btn++)
-			;
-		code = 32;
+
+		button = oldbutton + 32;
+		ox = x;
+		oy = y;
 	} else {
-		btn = e->xbutton.button;
-		/* Only buttons 1 through 11 can be encoded */
-		if (btn < 1 || btn > 11)
-			return;
-		if (e->type == ButtonRelease) {
+		if (!IS_SET(MODE_MOUSESGR) && e->xbutton.type == ButtonRelease) {
+			button = 3;
+		} else {
+			button -= Button1;
+			if (button >= 7)
+				button += 128 - 7;
+			else if (button >= 3)
+				button += 64 - 3;
+		}
+		if (e->xbutton.type == ButtonPress) {
+			oldbutton = button;
+			ox = x;
+			oy = y;
+		} else if (e->xbutton.type == ButtonRelease) {
+			oldbutton = 3;
 			/* MODE_MOUSEX10: no button release reporting */
 			if (IS_SET(MODE_MOUSEX10))
 				return;
-			/* Don't send release events for the scroll wheel */
-			if (btn == 4 || btn == 5)
+			if (button == 64 || button == 65)
 				return;
 		}
-		code = 0;
 	}
 
-	ox = x;
-	oy = y;
-
-	/* Encode btn into code. If no button is pressed for a motion event in
-	 * MODE_MOUSEMANY, then encode it as a release. */
-	if ((!IS_SET(MODE_MOUSESGR) && e->type == ButtonRelease) || btn == 12)
-		code += 3;
-	else if (btn >= 8)
-		code += 128 + btn - 8;
-	else if (btn >= 4)
-		code += 64 + btn - 4;
-	else
-		code += btn - 1;
-
 	if (!IS_SET(MODE_MOUSEX10)) {
-		code += ((state & ShiftMask  ) ?  4 : 0)
-		      + ((state & Mod1Mask   ) ?  8 : 0) /* meta key: alt */
-		      + ((state & ControlMask) ? 16 : 0);
+		button += ((state & ShiftMask  ) ? 4  : 0)
+			+ ((state & Mod4Mask   ) ? 8  : 0)
+			+ ((state & ControlMask) ? 16 : 0);
 	}
 
 	if (IS_SET(MODE_MOUSESGR)) {
 		len = snprintf(buf, sizeof(buf), "\033[<%d;%d;%d%c",
-				code, x+1, y+1,
-				e->type == ButtonRelease ? 'm' : 'M');
+				button, x+1, y+1,
+				e->xbutton.type == ButtonRelease ? 'm' : 'M');
 	} else if (x < 223 && y < 223) {
 		len = snprintf(buf, sizeof(buf), "\033[M%c%c%c",
-				32+code, 32+x+1, 32+y+1);
+				32+button, 32+x+1, 32+y+1);
 	} else {
 		return;
 	}
@@ -468,13 +458,9 @@ mouseaction(XEvent *e, uint release)
 void
 bpress(XEvent *e)
 {
-	int btn = e->xbutton.button;
 	struct timespec now;
 	int snap;
 
-	if (1 <= btn && btn <= 11)
-		buttons |= 1 << (btn-1);
-
 	if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
 		mousereport(e);
 		return;
@@ -483,7 +469,7 @@ bpress(XEvent *e)
 	if (mouseaction(e, 0))
 		return;
 
-	if (btn == Button1) {
+	if (e->xbutton.button == Button1) {
 		/*
 		 * If the user clicks below predefined timeouts specific
 		 * snapping behaviour is exposed.
@@ -697,11 +683,6 @@ xsetsel(char *str)
 void
 brelease(XEvent *e)
 {
-	int btn = e->xbutton.button;
-
-	if (1 <= btn && btn <= 11)
-		buttons &= ~(1 << (btn-1));
-
 	if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forcemousemod)) {
 		mousereport(e);
 		return;
@@ -709,7 +690,7 @@ brelease(XEvent *e)
 
 	if (mouseaction(e, 1))
 		return;
-	if (btn == Button1)
+	if (e->xbutton.button == Button1)
 		mousesel(e, 1);
 }
 
@@ -815,19 +796,6 @@ xloadcols(void)
 	loaded = 1;
 }
 
-int
-xgetcolor(int x, unsigned char *r, unsigned char *g, unsigned char *b)
-{
-	if (!BETWEEN(x, 0, dc.collen))
-		return 1;
-
-	*r = dc.col[x].color.red >> 8;
-	*g = dc.col[x].color.green >> 8;
-	*b = dc.col[x].color.blue >> 8;
-
-	return 0;
-}
-
 int
 xsetcolorname(int x, const char *name)
 {
@@ -981,7 +949,7 @@ xloadfont(Font *f, FcPattern *pattern)
 }
 
 void
-xloadfonts(const char *fontstr, double fontsize)
+xloadfonts(char *fontstr, double fontsize)
 {
 	FcPattern *pattern;
 	double fontval;
@@ -989,7 +957,7 @@ xloadfonts(const char *fontstr, double fontsize)
 	if (fontstr[0] == '-')
 		pattern = XftXlfdParse(fontstr, False, False);
 	else
-		pattern = FcNameParse((const FcChar8 *)fontstr);
+		pattern = FcNameParse((FcChar8 *)fontstr);
 
 	if (!pattern)
 		die("can't open font %s\n", fontstr);
@@ -1493,12 +1461,12 @@ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, i
 
 	/* Render underline and strikethrough. */
 	if (base.mode & ATTR_UNDERLINE) {
-		XftDrawRect(xw.draw, fg, winx, winy + dc.font.ascent * chscale + 1,
+		XftDrawRect(xw.draw, fg, winx, winy + dc.font.ascent + 1,
 				width, 1);
 	}
 
 	if (base.mode & ATTR_STRUCK) {
-		XftDrawRect(xw.draw, fg, winx, winy + 2 * dc.font.ascent * chscale / 3,
+		XftDrawRect(xw.draw, fg, winx, winy + 2 * dc.font.ascent / 3,
 				width, 1);
 	}
 
@@ -1617,9 +1585,8 @@ xseticontitle(char *p)
 	XTextProperty prop;
 	DEFAULT(p, opt_title);
 
-	if (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
-	                                &prop) != Success)
-		return;
+	Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
+			&prop);
 	XSetWMIconName(xw.dpy, xw.win, &prop);
 	XSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmiconname);
 	XFree(prop.value);
@@ -1631,14 +1598,94 @@ xsettitle(char *p)
 	XTextProperty prop;
 	DEFAULT(p, opt_title);
 
-	if (Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
-	                                &prop) != Success)
-		return;
+	Xutf8TextListToTextProperty(xw.dpy, &p, 1, XUTF8StringStyle,
+			&prop);
 	XSetWMName(xw.dpy, xw.win, &prop);
 	XSetTextProperty(xw.dpy, xw.win, &prop, xw.netwmname);
 	XFree(prop.value);
 }
 
+int
+xsixelinit(SixelContext *ctx)
+{
+	return sixel_parser_init(&ctx->state, 0, dc.col[defaultbg].pixel, 1, win.cw, win.ch);
+}
+
+int
+xsixelparse(SixelContext *ctx, unsigned char *u, int len)
+{
+	return sixel_parser_parse(&ctx->state, u, len);
+}
+
+void
+xsixelnewimage(SixelContext *ctx, int tx, int ty)
+{
+	ImageList *new_image;
+	int i;
+
+	new_image = malloc(sizeof(ImageList));
+	memset(new_image, 0, sizeof(ImageList));
+	new_image->x = tx;
+	new_image->y = ty;
+	new_image->width = ctx->state.image.width;
+	new_image->height = ctx->state.image.height;
+	new_image->pixels = malloc(new_image->width * new_image->height * 4);
+	if (sixel_parser_finalize(&ctx->state, new_image->pixels) != 0) {
+		perror("sixel_parser_finalize() failed");
+		sixel_parser_deinit(&ctx->state);
+		return;
+	}
+	sixel_parser_deinit(&ctx->state);
+	if (ctx->images) {
+		ImageList *im;
+		for (im = ctx->images; im->next;)
+			im = im->next;
+		im->next = new_image;
+		new_image->prev = im;
+	} else {
+		ctx->images = new_image;
+	}
+}
+
+void
+xsixeldeleteimage(SixelContext *ctx, ImageList *im)
+{
+	if (im->prev)
+		im->prev->next = im->next;
+	else
+		ctx->images = im->next;
+	if (im->next)
+		im->next->prev = im->prev;
+	if (im->pixmap)
+		XFreePixmap(xw.dpy, (Drawable)im->pixmap);
+	free(im->pixels);
+	free(im);
+}
+
+void
+xsixelscrolldown(SixelContext *ctx, int n, int bottom)
+{
+	ImageList *im;
+	for (im = ctx->images; im; im = im->next) {
+		if (im->y < bottom)
+			im->y += n;
+		if (im->y > bottom)
+			im->should_delete = 1;
+	}
+}
+
+void
+xsixelscrollup(SixelContext *ctx, int n, int top)
+{
+	ImageList *im;
+	for (im = ctx->images; im; im = im->next) {
+		if (im->y+im->height/win.ch > top)
+			im->y -= n;
+		if (im->y+im->height/win.ch < top)
+			im->should_delete = 1;
+	}
+}
+
 int
 xstartdraw(void)
 {
@@ -1676,6 +1723,88 @@ xdrawline(Line line, int x1, int y1, int x2)
 		xdrawglyphfontspecs(specs, base, i, ox, y1);
 }
 
+void
+xdrawsixel(SixelContext *ctx, Line *line, int row, int col)
+{
+	ImageList *im, *tmp;
+	int x, y;
+	int n = 0;
+	int nlimit = 256;
+	XRectangle *rects = NULL;
+	XGCValues gcvalues = { 0 };
+	GC gc;
+
+	for (im = ctx->images; im;) {
+		if (im->should_delete) {
+			tmp = im;
+			im = im->next;
+			xsixeldeleteimage(ctx, tmp);
+			continue;
+		}
+
+		if (!im->pixmap) {
+			im->pixmap = (void *)XCreatePixmap(xw.dpy, xw.win, im->width, im->height, DefaultDepth(xw.dpy, xw.scr));
+			XImage ximage = {
+				.format = ZPixmap,
+				.data = (char *)im->pixels,
+				.width = im->width,
+				.height = im->height,
+				.xoffset = 0,
+				.byte_order = LSBFirst,
+				.bitmap_bit_order = MSBFirst,
+				.bits_per_pixel = 32,
+				.bytes_per_line = im->width * 4,
+				.bitmap_unit = 32,
+				.bitmap_pad = 32,
+				.depth = 24
+			};
+			XPutImage(xw.dpy, (Drawable)im->pixmap, dc.gc, &ximage, 0, 0, 0, 0, im->width, im->height);
+			free(im->pixels);
+			im->pixels = NULL;
+		}
+		n = 0;
+		for (y = im->y; y < (im->y + (im->height + win.ch - 1) / win.ch) && y < row; y++) {
+			if (y >= 0) {
+				for (x = im->x; x < (im->x + (im->width + win.cw - 1) / win.cw) && x < col; x++) {
+					if (!rects)
+						rects = xmalloc(sizeof(XRectangle) * nlimit);
+					if (line[y][x].mode & ATTR_SIXEL) {
+						if (n > 0 && rects[n-1].x+rects[n-1].width == borderpx+x*win.cw && rects[n-1].y == borderpx+y*win.ch) {
+							rects[n-1].width += win.cw;
+						} else {
+							rects[n].x = borderpx+x*win.cw;
+							rects[n].y = borderpx+y*win.ch;
+							rects[n].width = win.cw;
+							rects[n].height = win.ch;
+							if (++n == nlimit && (rects = realloc(rects, sizeof(XRectangle) * (nlimit *= 2))) == NULL)
+								die("Out of memory\n");
+						}
+					}
+				}
+			}
+			if (n > 1 && rects[n-2].x == rects[n-1].x && rects[n-2].width == rects[n-1].width) {
+				if (rects[n-2].y+rects[n-2].height == rects[n-1].y) {
+					rects[n-2].height += win.ch;
+					n--;
+				}
+			}
+		}
+		if (n == 0) {
+			tmp = im;
+			im = im->next;
+			xsixeldeleteimage(ctx, tmp);
+			continue;
+		}
+		gc = XCreateGC(xw.dpy, xw.win, 0, &gcvalues);
+		if (n > 1)
+			XSetClipRectangles(xw.dpy, gc, 0, 0, rects, n, YXSorted);
+		XCopyArea(xw.dpy, (Drawable)im->pixmap, xw.buf, gc, 0, 0, im->width, im->height, borderpx + im->x * win.cw, borderpx + im->y * win.ch);
+		XFreeGC(xw.dpy, gc);
+		im = im->next;
+	}
+	free(rects);
+}
+
 void
 xfinishdraw(void)
 {
